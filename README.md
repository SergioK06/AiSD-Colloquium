# Коллоквиум по АиСД

## <ins> 1. Оценка сложности алгоритма по времени </ins> 

По сути подсчет кол-ва операций (арифметические операции,
операции сравнения, операции присваивания) в алгоритме.

Оценка по времени бывает сверху - O, снизу - Ω и точная (**существует тогда
и только тогда, когда верхняя и нижняя оценки совпадают**) - θ.

Сложность по времени зависит в большей степени от программиста.

**Определение** Пусть f(n) — функция. Тогда, функция
g(n) = O(f(n)), если существуют такие константы c и
*n<sub>0</sub>*, что g(n) < c·f(n) для всех n≥n<sub>0</sub>.

В контексте анализа алгоритмов, фраза «алгоритм работает за
O(f(n)) операций» означает, что начиная с какого-то n он делает
не более чем за c⋅f(n) операций.

## <ins> 2. Оценка сложности алгоритма по памяти </ins>

По сути подсчет кол-ва переменных в алгоритме:

- 1 переменная - 1 пункт сложности
- Массив размером n - n пунктов сложности
- Строка длинной n - n пунктов сложности

Сложность по памяти более предсказуема, чем сложность по времени
и чаще всего определена размером входных данных.

## <ins> 3. Сортировка вставками (Insertion sort) </ins>

Главные принципы:
- Первый элемент считаем отсортированной частью
- Начиная со второго: 
  - просматриваем элементы слева направо от i к i+1
  - выполняем вставку просматриваемого элемента в отсортированную часть
  - после вставки увеличиваем размер отсортированной части

Инвариант: все элементы до i-ого отсортированы

Устойчивая

Оценка по времени: 
- лучший: O(n)
- средний/худший: O(n<sup>2</sup>)

Оценка по памяти: O(1)

Код:
```c++
for (int i=1; i<n; i++) {
    int key = a[i];
    int j = i-1;
    while(a[j] > key and j >= 0) {
        a[j+1] = a[j];
        j -= 1;
    }
    a[j+1] = key;
}
```

## <ins> 4. Сортировка слиянием (Merge Sort) </ins>

Главные принципы:
- "Разделяй и властвуй"/Метод декомпозиции (Задача разбивается на подзадачи):
  - Задача разделяется на подзадачи и выбран размер подзадач, до которого
идет разбиение (1 элемент - отсортирован относительно самого себя)
  - Корректный сбор решения подзадач, чтобы в итоге решить изначальную задачу
  - Рекурсия - эффективный способ реализовать этот подход
- Объединяем решение по парам: например, два одно элементных в двух элементные
- Не всегда разбиения будут четными => можем объединять одно и двух 
элементные
- Рекурсия: на спуске - разбиваем, на подъеме - сортируем в 
рамках подзадач и объединяем решения

Инвариант: при слиянии (подъеме) оба массива отсортированы

Устойчивая

Оценка по времени: O(n⋅log(n)), т.к. проход по массиву ⋅ рекурсия разбиения (постоянно
делим массив пополам)

Оценка по памяти: O(n), т.к. создается массив res

Код:
```c++
void merge(int left, int mid, int right) {
    int l = 0;
    int r = 0;
    int res[right-left];
    while (left + l < mid && mid + r < right) {
        if (a[left+l] <= a[mid + r]) {
            res[l+r]=a[left+l];
            l++;
        }
        else {
            res[r+l]=a[mid+r];
            r++;
        }
    }
    while (left + l < mid) {
        res[l+r] = a[left+l];
        l++;
    }
    while (mid + r < right) {
        res[r+l] = a[mid+r];
        r++;
    }
    for (int i = 0; i < l+r; i++) {
        a[left+i] = res[i];
    }
}

void mergeSortRecursive(int left, int right) {
    if (left+1 >= right) {
        return;
    }
    int mid = (left + right) / 2;
    mergeSortRecursive(left, mid);
    mergeSortRecursive(mid, right);
    merge(left, mid, right);
}
```

## <ins> 5. Быстрая сортировка (Quick Sort) </ins>

Главные принципы:
- Разбиение:
  - выбираем опорный элемент
  - делим массив, относительно опорного элемента, на две части, слева - 
меньше него, а справа больше
- Запускаем процесс разбиения отдельно в левой и правой частях полученного
массива ("разделяй и властвуй")

В основном под Быстрой сортировкой (Quick Sort) подразумевают сортировку
Хоара, но еще возможна и сортировка Ломуто.

**Разбиение Ломуто:**
- Опорным выбирается последний элемент в рассматриваемой части массива
- Необходимо 2 индекса:
  - i – отвечает за границу элементов меньших опорного, на старте считаем, что
таких элементов нет
  - j - для просмотра массива
- Просматриваем массив, и каждый раз, когда находится элемент, меньший
либо равный опорному, увеличиваем границу элементов меньших опорного (индекс i)
и вставляем найденный элемент перед опорным в зону меньших опорного

**Разбиение Хоара:**
- Опорным выбирается элемент в середине массива, относительно него идет
разбиение
- Необходимо 2 индекса (i в начале массива, j – в конце), которые приближаются
друг к другу, пока не найдется пара элементов:
  - по i: элемент больше опорного и расположен перед ним (до среднего элемента)
  - по j: элемент меньше опорного и расположен после него (после среднего элемента)
- Найденные элементы меняются местами
- Обмен происходит до тех пор, пока индексы i и j не пересекутся

Разбиение Хоара эффективнее разбиения Ломуто, т. к. происходит в среднем в 3 раза
меньше обменов (swap) элементов, и разбиение эффективнее даже когда все элементы
равны

Следует заметить, что конечная позиция опорного элемента необязательно совпадает с его
начальной позицией (в середине массива)

Инвариант: элементы левее опорного меньше него, а правее - больше или равны

Неустойчивая

Оценка по времени:
- лучший/средний: O(n⋅log(n)), т.к. проход по массиву ⋅ рекурсия разбиения
- худший: O(n<sup>2</sup>), при постоянном разбиении на 1 и n-1

Оценка по памяти: 
- лучший/средний: O(log(n)), т.к. log n - глубина рекурсии
- худший: O(n), при постоянном разбиении на 1 и n-1

Модификации Quick Sort:
- среднее значение между крайними
- выбор опорного элемента с помощью random
- медиана из 3-х

Код (Хоара + модификация(среднее значение между крайними)):
```c++
void QuickSort(int l, int r) {
    int i = l, j = r;
    int mid = (a[l] + a[r]) / 2;

    while (i <= j) {
        while (a[i] < mid) {
            i++;
        }
        while (a[j] > mid) {
            j--;
        }
        if (i <= j) {
            swap(a[i], a[j]);
            i++;
            j--;
        }
    }
    if (j > l) {
        QuickSort(l, j);
    }
    if (r > i) {
        QuickSort(i, r);
    }
};
```

## <ins> 6. Сортировка подсчетом (Counting Sort) </ins>

Главные принципы:
- Исходная последовательность чисел длины n , а в конце отсортированная, 
хранится в массиве A. Также используется вспомогательный массив C с индексами
от 0 до k−1, изначально заполняемый нулями
- Последовательно пройдём по массиву A и запишем в C[i] количество чисел,
равных i
- Теперь достаточно пройти по массиву C и для каждого number∈{0,...,k−1}
в массив A последовательно записать число C[number] раз.

Сортировать можно не только числа, поэтому можно создать вспомогательный
массив B (по длине равный массиву A).

